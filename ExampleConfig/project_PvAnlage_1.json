{
    # Anlage vom Boaschti
    "MqttBridge":
    {
        "class":      "MqttBridge.MqttBridge.MqttBridge",
        "startPriority" : -8,
        "interfaces":
        {
            "Mosquitto":
            {
            "connection":   "Interface.Ethernet.MqttBrokerInterface.MqttBrokerInterface"
            }
         }
    },

    "Logger":
    {
     "projectName":   "HomeAccu"
     },

    "West":
    {
        "class":        "Inverter.EffektaController.EffektaController",
        "bmsName": "Bms",
        "boostTime"   : 30,                 # optional if bmsName sends this parameters, the minimum of this parameter will be written
        "interfaces":
        {
            "UartWrEffektaWest":
            {
                "connection":   "Interface.Uart.EffektaUartInterface.EffektaUartInterface",
                "interface":    "/dev/serial/by-id/usb-FTDI_FT232R_USB_UART_A9A5YBUE-if00-port0"
            }
        }
    },

    "Ost":
    {
        "class":        "Inverter.EffektaController.EffektaController",
        "bmsName": "Bms",
        "boostTime"   : 30,                 # optional if bmsName sends this parameters, the minimum of this parameter will be written
        "interfaces":
        {
            "UartWrEffektaOst":
            {
                "connection":   "Interface.Uart.EffektaUartInterface.EffektaUartInterface",
                "interface":    "/dev/serial/by-id/usb-FTDI_FT232R_USB_UART_A9HSILDS-if00-port0"
            }
        }
    },

    "Balkon":
    {
        "class":        "Charger.GenericCharger.GenericCharger",
        "interfaces":
        {
            "EpeverInterface":
            {
                "connection":   "Interface.Uart.Epever485Interface.Epever485Interface",
                "interface":    "/dev/serial/by-path/platform-3f980000.usb-usb-0:1.2.4.4:1.0-port0",
                "boostVoltage": 56.0,          # optional
                "floatVoltage": 54.6,          # optional, if both voltages are given we configure epever
                "address":     1
            }
        }
    },

    "Bms":
    {
        "class":                        "BMS.BasicBms.BasicBms",
        "interfaces":
        {
            "BmsJk":
            {
                "connection":   "Interface.Uart.JkPbInverterBmsInterface.JkPbInverterBmsInterface",
                "address":      1,
                "numBatterys":  1,          # optional
                "interface":    "/dev/serial/by-path/platform-3f980000.usb-usb-0:1.2.4.2:1.0-port0"
            },
            "BmsJk318":
            {
                "connection":   "Interface.Uart.JkPbInverterBmsInterface.JkPbInverterBmsInterface",
                "address":      2,
                "numBatterys":  1,          # optional
                "interface":    "/dev/serial/by-path/platform-3f980000.usb-usb-0:1.2.4.1:1.0-port0"
            }
        }
    },

    "UsbRelais":
    {
        "class":        "GPIO.BasicUsbRelais.BasicUsbRelais",
        "gpioHandler": ["PowerPlant", "Bms"],
        "triggerThread":   "Bms",
        "relMapping":{"relWr": ["Relay0", "Relay1"], "relPvAus": "Relay3", "relNetzAus": "Relay4", "relBalance": "Relay5"},
        "inputMapping":{"Input1":"inverterActive"},
        "interfaces":
        {
            "WdUsbRelais":
            {
                "connection":   "Interface.Uart.WatchdogRelaisUartInterface.WatchdogRelaisUartInterface",
                #"interface":    "/dev/serial/by-path/platform-3f980000.usb-usb-0:1.3:1.0-port0",
                "interface":    "/dev/serial/by-path/platform-3f980000.usb-usb-0:1.2.3:1.0-port0",
                "rebind":       false    # todo prüfen. Es wird der jbd mit rausgehauen (logisch) die Class hat dann ein Problem beim wiederverbinden
            }
        }
    },

    "WdDcVerteiler":
    {
        "class":        "GPIO.BasicUsbRelais.BasicUsbRelais",
        "gpioHandler": ["PowerPlant"],
        "triggerThread":   "Bms",
        "relMapping":{"relStartBattery": "Relay2", "relPrecharge": "Relay1", "relStartPv": "Relay5", "relPowerPlantWaiting": "Relay3", "relPowerPlantRunning": "Relay6"},
        "inputMapping":{"Input2":"NotAusOk"},
        "interfaces":
        {
            "WdUsbRelaisDcInterface":
            {
                "connection":   "Interface.Uart.WatchdogRelaisUartInterface.WatchdogRelaisUartInterface",
                "interface":    "/dev/serial/by-path/platform-3f980000.usb-usb-0:1.2.4.3:1.0-port0",
                "testBypass":   "Relay0",                # optional to bypass wd relay during wd relay test. Input1 is used for bypass readback.
                "rebind":       false    # todo prüfen. Es wird der jbd mit rausgehauen (logisch) die Class hat dann ein Problem beim wiederverbinden
            }
        }
    },

    "WatchDog":
    {
        "startPriority" : -8,  # priorities work similar to linux nice levels, the more negative a value is the higher start priority it has, tasks without priority have priority 0 by default
        "class":      "WatchDog.WatchDog.WatchDog",
        "interfaces":
        {
        },
        "setupTime":      100,              # additional time until first check if all threads and only these are registered to give the threads some time to come up (timeout will happen after setupTime + triggerTime + timeout)
        "triggerTime":     10,              # after that time threads should start sending alive message to watch dog
        "timeout":         10,              # n seconds timeout after ticker time, after triggerTime + timeout watch dog will raise an Exception
        "warningTime":     3,               # if minimum measured remaining timeout time is less or equal warningTime log a warning to inform the user about critical timing
        "expectThreads":                    # expected threads
        [
            "Logger",
            "PowerPlant",
            "Mosquitto",
            "MqttBridge",
            "West",
            "Ost",
            "Balkon",
            "Bms",
            "UsbRelais", 
            "WdDcVerteiler"
        ],
        "ignoreThreads":                    # no timeout monitoring for these ones... but they have to be included in expectedThreads
        [
            "UartWrEffektaWest",
            "UartWrEffektaOst",
            "BmsJk",
            "BmsJk318",
            "EpeverInterface",
            "WdUsbRelais",
            "Wetter",
            "WdUsbRelaisDcInterface"
        ]
    },

    "PowerPlant":
    {
        "class": "Worker.PowerPlant.PowerPlant",
        "managedEffektas": ["West", "Ost"],
        "socMonitorName": "Bms",
        "bmsName": "Bms",
        "resetFullchargeRequiredWithFloatmode": true,       # optional, if FullChargeRequired is used to reference soc monitor it is neccessary to reset this bit if floatMode from the inverter is detected, if FullChargeRequired is used to balance battery and the bms or interface is able to send finally 100% soc. E.g. soc is 90% due balancing and 100% at the end of balancing.
        "weatherName": "Wetter",                            # optional
        "initModeEffekta": "Auto",                          # Auto, Akku, Netz.  Fallback: Netz
        "inputs":["UsbRelais", "WdDcVerteiler"],
        "manualDcBoxStart": false,
        "prechargeTime": 3                                 # precharge time for upper funktion
    },

    "Wetter":
    {
        "class": "Weather.Weather.WetterOnline"
    },

    "@import": [
        "json/secure.json"
    ]
}

